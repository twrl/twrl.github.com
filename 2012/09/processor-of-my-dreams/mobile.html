<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

	<title>twrl - The Processor of my Dreams</title>

	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>

	<link href='http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Sans+Mono' rel='stylesheet' type='text/css'/>

	<link rel="stylesheet" href="/css/mobile.css" />
  <link rel="stylesheet" href="http://code.jquery.com/mobile/1.1.1/jquery.mobile.structure-1.1.1.min.css" />
	<link rel="stylesheet" href="/css/code.css" />
	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
	<script src="http://code.jquery.com/mobile/1.1.1/jquery.mobile-1.1.1.min.js"></script>

</head>
<body>

		<div data-role="page" data-add-back-btn="true" data-theme="f">
		<div data-role="header">
			<h1>The Processor of my Dreams</h1>
		</div>
		<div data-role="content">

			<p>My recent forays into Operating System Development have made me more aware of 
the pros and cons of the x86 processor. It&rsquo;s not all bad.</p>

<p>It is impressive that software written for the 8086, which was released 35 years
ago, will still run without modification on the latest Intel i7 or AMD A-series.
But it&rsquo;s also a burden, because as anyone who has ever tried to manipulate the
Global Descriptor Table will tell you, holding on to back-compatibility has
led to some hideously fragmented data structures and seemingly nonsense 
behaviour.</p>

<p>Anyway, this set me to thinking about what features I would like in a processor.
In terms of what I&rsquo;d like to see in a future iteration of the x86, we have:</p>

<ul>
  <li>
    <p>128-bit General Purpose registers. Bonus points if it can be initialized
with random data (for UUID generation), and if you can lock the value of the
high n-bits (for working with IPv6 addresses).</p>
  </li>
  <li>
    <p>Hardware synchronisation primitives. It would be simple to add a circuit
connected to all (logical) cores which allows you to add, test, and remove
an integer from a list of active locks. In multi-chip setups you&rsquo;d need some
sort of memory coherence to keep each chip in sync, but we&rsquo;d be talking 
of quite small amounts of data on fast buses and independent of the main
load-store unit.</p>
  </li>
  <li>
    <p>Updated configuration and mode selection mechanism. I understand why the x86
has fixed data structures and an array of registers to set it&rsquo;s operating
mode and configuration, but it&rsquo;s a nightmare. There are three million steps
to do anything, most processor features are controlled in fundamentally
different ways, and the BIOS/EFI/Bootloader/etc. may or may not have already
set or unset various things - including some which can&rsquo;t easily be tested
for. By all means keep these things for legacy support. But why not
implement a new, simple, single configuration meachanism. I want to say 
&ldquo;load a 24-byte configuration packet from this address&rdquo; and have the CPU
execute my instructions. You can have variable length packets, make it
arbitrarily extensible. You can even include a query mechanism in the 
protocol and make it bidirectional. </p>
  </li>
</ul>

<p>Now if I were designing a new CPU, there&rsquo;s a few things I&rsquo;d add to this:</p>

<ul>
  <li>
    <p>Seperate call and data stacks. Keeping track of the stack frame is fiddly,
and for low level programming unwinding exceptions is impractical, when you
have a single stack.</p>
  </li>
  <li>
    <p>Structure mutation area. Why not have a 1024-bit register, into which you 
can load a large data structure? Make it size-aligned subaddressable (so 128 
bytes, or 64 words, or 32 dwords, or 16 qwords, etc). Then you can do 
mutations of that data structure, which because it&rsquo;s a CPU register will be 
very fast and cheap, and flush it back out to main memory once you&rsquo;re done.
For 128 bytes natural aligned it so happens there&rsquo;s a very efficient coding
of all possible size/offset combinations into 1 byte too :)</p>
  </li>
</ul>

<p>There&rsquo;s almost certainly more things I could add to this. Mechanisms to enforce
bounds on data structures, to resolve arbitrary identifiers to pointers, and
to fire arbitrary events (interrupts and exceptions being a hardware-defined
subset of &lsquo;event&rsquo;) all spring to mind. Slightly more outlandish, but the ability
to emulate CAM in main memory might be fun (and could underpin several of the
above).</p>

<p>(Un)fortunately I know very little about CPU microarchitecture, and Verilog 
makes my head hurt, so Intel and AMD are safe from competetion. For now&hellip;</p>


			<div data-role="collapsible" data-inset="true" data-content-theme="g">
				<h3>About this post</h3>

				<p>Published on <time pubdate>21 September, 2012</time></p>
				<p>Tags: <a href="/tags/x86/mobile.html">x86</a>, <a href="/tags/processor-architecture/mobile.html">Processor Architecture</a>, <a href="/tags/programming/mobile.html">Programming</a></p>

				<p><a href="/2012/09/processor-of-my-dreams//index.html">Desktop view</a></p>
			</div> 
			<div data-role="collapsible" data-inset="true" data-content-theme="g">
				<h3>Comments</h3>

				<script type="text/javascript">
		    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
		    var disqus_shortname = 'twrl'; // required: replace example with your forum shortname
			var disqus_identifier = '/2012/09/processor-of-my-dreams/';

		    /* * * DON'T EDIT BELOW THIS LINE * * */
		    (function() {
		        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		    })();
		</script>
		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
		<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			</div>
		</div>
	</div>


</body>
</html>
